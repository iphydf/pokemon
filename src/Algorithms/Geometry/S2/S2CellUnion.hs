-- An S2CellUnion is a region consisting of cells of various sizes.  Typically
-- a cell union is used to approximate some other shape.  There is a tradeoff
-- between the accuracy of the approximation and how many cells are used.
-- Unlike polygons, cells have a fixed hierarchical structure.  This makes
-- them more suitable for optimizations based on preprocessing.
module Algorithms.Geometry.S2.S2CellUnion where

import           Data.Word                       (Word64)

import           Algorithms.Geometry.S2.S1Angle
import qualified Algorithms.Geometry.S2.S2       as S2
import           Algorithms.Geometry.S2.S2CellId (S2CellId)
import qualified Algorithms.Geometry.S2.S2CellId as S2CellId
import           Algorithms.Geometry.S2.S2Region


-- The default constructor does nothing.  The cell union cannot be used
-- until one of the Init() methods is called.
data S2CellUnion = S2CellUnion
  {Â cellIds :: [S2CellId]
    -- ^ Direct access to the underlying vector for STL algorithms.
  }


-- Populates a cell union with the given S2CellIds or 64-bit cells ids, and
-- then calls Normalize().  The InitSwap() version takes ownership of the
-- vector data without copying and clears the given vector.  These methods
-- may be called multiple times.
fromS2CellIds :: [S2CellId] -> S2CellUnion
fromS2CellIds = error "fromS2CellIds"

fromCellIds :: [Word64] -> S2CellUnion
fromCellIds = error "fromCellIds"


-- Like Init(), but does not call Normalize().  The cell union *must* be
-- normalized before doing any calculations with it, so it is the caller's
-- responsibility to make sure that the input is normalized.  This method is
-- useful when converting cell unions to another representation and back.
-- These methods may be called multiple times.
fromS2CellIdsRaw :: [S2CellId] -> S2CellUnion
fromS2CellIdsRaw = error "fromS2CellIdsRaw"

fromCellIdsRaw :: [Word64] -> S2CellUnion
fromCellIdsRaw = error "fromCellIdsRaw"


-- Convenience methods for accessing the individual cell ids.
numCells :: S2CellUnion -> Int
numCells = length . cellIds

cellId :: S2CellUnion -> Int -> S2CellId
cellId = (!!) . cellIds


-- Normalizes the cell union by discarding cells that are contained by other
-- cells, replacing groups of 4 child cells by their parent cell whenever
-- possible, and sorting all the cell ids in increasing order.  Returns true
-- if the number of cells was reduced.
--
-- This method *must* be called before doing any calculations on the cell
-- union, such as Intersects() or Contains().
normalize :: S2CellUnion -> S2CellUnion
normalize = error "normalize"


-- Replaces "output" with an expanded version of the cell union where any
-- cells whose level is less than "min_level" or where (level - min_level)
-- is not a multiple of "level_mod" are replaced by their children, until
-- either both of these conditions are satisfied or the maximum level is
-- reached.
--
-- This method allows a covering generated by S2RegionCoverer using
-- min_level() or level_mod() constraints to be stored as a normalized cell
-- union (which allows various geometric computations to be done) and then
-- converted back to the original list of cell ids that satisfies the
-- desired constraints.
denormalize :: S2CellUnion -> Int -> Int -> [S2CellId]
denormalize cu minLevel levelMod =
  go 0 []
  where
    go i output
      | i < numCells cu =
          let
            cid = cellId cu i
            level = S2CellId.level cid
            newLevel' = max minLevel level
            -- Round up so that (new_level - min_level) is a multiple of level_mod.
            -- (Note that S2CellId::kMaxLevel is a multiple of 1, 2, and 3.)
            newLevel = min S2.maxCellLevel $ newLevel' + (S2.maxCellLevel - (newLevel' - minLevel)) `rem` levelMod
          in
          if newLevel == level
            then go (i + 1) (cid : output)
            else go (i + 1) (S2CellId.children cid ++ output)
      | otherwise = output


-- If there are more than "excess" elements of the cell_ids() vector that
-- are allocated but unused, reallocate the array to eliminate the excess
-- space.  This reduces memory usage when many cell unions need to be held
-- in memory at once.
pack :: S2CellUnion -> Int -> S2CellUnion
pack = error "pack"


-- Return true if the cell union contains the given cell id.  Containment is
-- defined with respect to regions, e.g. a cell contains its 4 children.
-- This is a fast operation (logarithmic in the size of the cell union).
containsCell :: S2CellUnion -> S2CellId -> Bool
containsCell = error "containsCell"


-- Return true if the cell union intersects the given cell id.
-- This is a fast operation (logarithmic in the size of the cell union).
intersectsCell :: S2CellUnion -> S2CellId -> Bool
intersectsCell = error "intersectsCell"


-- Return true if this cell union contain/intersects the given other cell
-- union.
contains :: S2CellUnion -> S2CellUnion -> Bool
contains = error "contains"

intersects :: S2CellUnion -> S2CellUnion -> Bool
intersects = error "intersects"


-- Initialize this cell union to the union, intersection, or
-- difference (x - y) of the two given cell unions.
-- Requires: x != this and y != this.
union :: S2CellUnion -> S2CellUnion -> S2CellUnion
union = error "union"

intersection :: S2CellUnion -> S2CellUnion -> S2CellUnion
intersection = error "intersection"

difference :: S2CellUnion -> S2CellUnion -> S2CellUnion
difference = error "difference"


-- Specialized version of GetIntersection() that gets the intersection of a
-- cell union with the given cell id.  This can be useful for "splitting" a
-- cell union into chunks.
intersectionWithCellId :: S2CellUnion -> S2CellId -> S2CellUnion
intersectionWithCellId = error "intersectionWithCellId"


-- Expands the cell union by adding a "rim" of cells on expand_level
-- around the union boundary.
--
-- For each cell c in the union, we add all cells at level
-- expand_level that abut c.  There are typically eight of those
-- (four edge-abutting and four sharing a vertex).  However, if c is
-- finer than expand_level, we add all cells abutting
-- c.parent(expand_level) as well as c.parent(expand_level) itself,
-- as an expand_level cell rarely abuts a smaller cell.
--
-- Note that the size of the output is exponential in
-- "expand_level".  For example, if expand_level == 20 and the input
-- has a cell at level 10, there will be on the order of 4000
-- adjacent cells in the output.  For most applications the
-- Expand(min_radius, max_level_diff) method below is easier to use.
expand :: S2CellUnion -> Int -> S2CellUnion
expand = error "expand"


-- Expand the cell union such that it contains all points whose distance to
-- the cell union is at most "min_radius", but do not use cells that are
-- more than "max_level_diff" levels higher than the largest cell in the
-- input.  The second parameter controls the tradeoff between accuracy and
-- output size when a large region is being expanded by a small amount
-- (e.g. expanding Canada by 1km).  For example, if max_level_diff == 4 the
-- region will always be expanded by approximately 1/16 the width of its
-- largest cell.  Note that in the worst case, the number of cells in the
-- output can be up to 4 * (1 + 2 ** max_level_diff) times larger than the
-- number of cells in the input.
expandRadius :: S2CellUnion -> S1Angle -> Int -> S2CellUnion
expandRadius = error "expandRadius"


-- Create a cell union that corresponds to a continuous range of cell ids.
-- The output is a normalized collection of cell ids that covers the leaf
-- cells between "min_id" and "max_id" inclusive.
-- Requires: min_id.is_leaf(), max_id.is_leaf(), min_id <= max_id.
fromRange :: S2CellId -> S2CellId -> S2CellUnion
fromRange = error "fromRange"


-- The number of leaf cells covered by the union.
-- This will be no more than 6*2^60 for the whole sphere.
leafCellsCovered :: S2CellUnion -> Word64
leafCellsCovered = error "leafCellsCovered"


-- Approximate this cell union's area by summing the average area of
-- each contained cell's average area, using the AverageArea method
-- from the S2Cell class.
-- This is equivalent to the number of leaves covered, multiplied by
-- the average area of a leaf.
-- Note that AverageArea does not take into account distortion of cell, and
-- thus may be off by up to a factor of 1.7.
-- NOTE: Since this is proportional to LeafCellsCovered(), it is
-- always better to use the other function if all you care about is
-- the relative average area between objects.
averageBasedArea :: S2CellUnion -> Double
averageBasedArea = error "averageBasedArea"

-- Calculates this cell union's area by summing the approximate area for each
-- contained cell, using the ApproxArea method from the S2Cell class.
approxArea :: S2CellUnion -> Double
approxArea = error "approxArea"

-- Calculates this cell union's area by summing the exact area for each
-- contained cell, using the Exact method from the S2Cell class.
exactArea :: S2CellUnion -> Double
exactArea = error "exactArea"


------------------------------------------------------------------------
-- S2Region interface (see s2region.h for details):

instance S2Region S2CellUnion where
  getCapBound = error "getCapBound"
  getRectBound = error "getRectBound"
  -- This is a fast operation (logarithmic in the size of the cell union).
  containsCell = error "containsCell"
  -- This is a fast operation (logarithmic in the size of the cell union).
  mayIntersect = error "mayIntersect"
  -- The point 'p' does not need to be normalized.
  -- This is a fast operation (logarithmic in the size of the cell union).
  virtualContainsPoint = error "virtualContainsPoint"
